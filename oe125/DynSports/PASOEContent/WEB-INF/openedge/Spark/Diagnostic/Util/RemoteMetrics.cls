/*------------------------------------------------------------------------
   File        : RemoteMetrics
   Purpose     : Utilize the OEManager or JMX tools to gather info on
                 metrics for the current PASOE instance (agent/session)
   Description :
   Author(s)   : Irfan Syed (isyed@progress.com), Dustin Grau (dugrau@progress.com)
   Created     : Tue Nov 28 14:07:12 EST 2017
   Notes       : Requires OpenEdge 11.7.3 or later!
 ----------------------------------------------------------------------*/


block-level on error undo, throw.

using OpenEdge.Net.HTTP.Credentials from propath.
using OpenEdge.Net.HTTP.HttpClient from propath.
using OpenEdge.Net.HTTP.IHttpRequest from propath.
using OpenEdge.Net.HTTP.IHttpResponse from propath.
using OpenEdge.Net.HTTP.MethodEnum from propath.
using OpenEdge.Net.HTTP.RequestBuilder from propath.
using Progress.Json.ObjectModel.JsonArray from propath.
using Progress.Json.ObjectModel.JsonDataType from propath.
using Progress.Json.ObjectModel.JsonObject from propath.
using Progress.Json.ObjectModel.ObjectModelParser from propath.
using Progress.Lang.AppError from propath.

class Spark.Diagnostic.Util.RemoteMetrics inherits Spark.Diagnostic.Util.Logger use-widget-pool final:

    /*** Static Properties ***/

    /* Contains each ABL Applciation name as property and its Agent PID's as values. */
    define public static property Applications as JsonObject no-undo get. private set.

    /* Default to OEManager which is the preferred means of accessing metrics. */
    define private property MetricSource as character no-undo initial "oemanager" get. set.

    /*** OEManager Properties ***/

    /* Base URL for instance, where OEManager should reside. */
    define public property InstanceURI as character no-undo initial "" get. set.

    /* Default used with OEManager. */
    define public property ManagerRealm as character no-undo initial "PASOE Manager Application" get. set.

    /* Default used with OEManager. (Insecure for production use, please change/override!) */
    define public property ManagerUsername as character no-undo initial "tomcat" get. set.

    /* Default used with OEManager. (Insecure for production use, please change/override!) */
    define public property ManagerPassword as character no-undo initial "tomcat" get. set.

    /* Name of the Tomcat WebApp which contains the OEManager application. */
    define private property ManagerURI as character no-undo initial "/oemanager" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents */
    define private property GetAllAgentsURI as character no-undo
        initial "/applications/&1/agents" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents/<agent_id> */
    define private property GetAgentURI as character no-undo
        initial "/applications/&1/agents/&2" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents/<agent_id> */
    define private property GetRequestsURI as character no-undo
        initial "/applications/&1/agents/&2/requests" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents/<agent_id>/sessions */
    define private property GetAgentSessionURI as character no-undo
        initial "/applications/&1/agents/&2/sessions" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents/<agent_id>/ABLObjects/status */
    define private property TrackObjects as character no-undo
        initial "/ABLObjects/status" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents/<agent_id>/ABLObjects */
    define private property GetObjectsReport as character no-undo
        initial "/ABLObjects" get. set.

    /* scheme://server:port/oemanager/applications/<app_name>/agents/<agent_id>/ABLObjects/sessions/<sess_id> */
    define private property GetSessionObjectsReport as character no-undo
        initial "/ABLObjects/sessions/&3" get. set.

    /*** OEJMX Properties ***/

    /* Binary should reside in CATALINA_BASE/bin/ as a .bat/.sh script. */
    define private property OEJMXBinary as character no-undo initial ""
        get():
            if OEJMXBinary eq "" then
                assign OEJMXBinary = if opsys eq "WIN32" then "oejmx.bat" else "oejmx.sh".
            return OEJMXBinary.
        end get.
        set.

    /* Replace with Application Name in query. */
    define private property AgentsQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["getAgents","&1"]~}'
        get. set.

    /* Replace with Agent ID (PID) in query. */
    define private property SessionsQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["getSessionMetrics","&1"]~}'
        get. set.

    /* Replace with Agent ID (PID) in query. */
    define private property RequestsQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["getRequestMetrics","&1"]~}'
        get. set.

    /* Replace with Agent ID (PID) in query. */
    define private property TrackOnQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["trackABLObjects","&1",true]~}'
        get. set.

    /* Replace with Agent ID (PID) in query. */
    define private property TrackOffQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["trackABLObjects","&1",false]~}'
        get. set.

    /* Replace with Agent ID (PID) in query. */
    define private property TrackingQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["trackingABLObjects","&1"]~}'
        get. set.

    /* Replace with Agent ID (PID) in query. */
    define private property ABLObjectsQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["getABLObjectsReport","&1"]~}'
        get. set.

    /* Replace with Agent ID (PID) and Session ID in query. */
    define private property ABLSessionObjectsQuery as character no-undo
        initial '~{"O":"PASOE:type=OEManager,name=AgentManager","M":["getABLSessionObjectsReport","&1",&2]~}'
        get. set.


    /***** Constructor/Destructor *****/


    constructor public RemoteMetrics ( input pcSource as character ):
        super().

        /* Make sure we have a consistent path for temporary files. */
        os-create-dir value(substitute("&1", this-object:TemporaryDir)).
        os-create-dir value(substitute("&1/metrics", this-object:TemporaryDir)).
        os-create-dir value(substitute("&1/metrics/ABLObjects", this-object:TemporaryDir)).

        /* Set the means of obtaining metrics, or a sane default. */
        case pcSource:
            when "java" or
            when "oejmx" or
            when "jmx" then
                assign this-object:MetricSource = "oejmx".
            when "webapp" or
            when "oemanager" or
            when "oem" then
                assign this-object:MetricSource = "oemanager".
            otherwise
                assign this-object:MetricSource = "oejmx".
        end case.
        this-object:CheckTempPath().

        Applications = new JsonObject(). /* Create new, empty object. */
    end constructor.


    destructor public RemoteMetrics ( ):
        delete object oLogger no-error.
    end destructor.


    /***** Private Methods *****/


    method private void CheckTempPath ( ):
        /* Make sure we have a consistent path for temporary files. */
        os-create-dir value(substitute("&1", this-object:TemporaryDir)).
        os-create-dir value(substitute("&1/metrics", this-object:TemporaryDir)).
    end method. /* CheckTempPath */


    method private JsonObject InvokeAPI ( input pcRequestURI as character ):
        /* Request the necessary information via GET by default. */
        return this-object:InvokeAPI(pcRequestURI, MethodEnum:GET, ?).
    end method. /* InvokeAPI */


    method private JsonObject InvokeAPI ( input pcRequestURI  as character,
                                          input poHttpMethod  as MethodEnum,
                                          input poRequestData as JsonObject ):
        /**
         * Use the OEManager webapp to run the necessary queries on the PAS
         * instance. This requires use of the OEHttpClient library to make
         * an API call via REST. For environments where OEManager is not
         * available or desired, use the OEJMX approach.
         */
        define variable oHttpReq     as IHttpRequest  no-undo.
        define variable oHttpResp    as IHttpResponse no-undo.
        define variable oCredentials as Credentials   no-undo.

        if (pcRequestURI gt "") ne true then
            undo, throw new AppError("No request URI provided.", 0).

        /* Report which endpoint is being access, with verb and payload (if available). */
        oLogger:Debug(substitute("Invoking: &1 &2 &3", poHttpMethod:ToString(), pcRequestURI)).
        if valid-object(poRequestData) then
            oLogger:Trace(substitute("Invoke Payload: &1 bytes", length(poRequestData:getJsonText(), "raw"))).

        /* Set credentials for HTTP basic using the specific realm. */
        assign oCredentials = new Credentials(this-object:ManagerRealm,
                                              this-object:ManagerUsername,
                                              this-object:ManagerPassword).
        if poHttpMethod eq MethodEnum:put then
            oHttpReq = RequestBuilder:Put(pcRequestURI, poRequestData)
                                     :ContentType("application/vnd.progress+json")
                                     :UsingBasicAuthentication(oCredentials)
                                     :Request.
        else
            oHttpReq = RequestBuilder:Get(pcRequestURI)
                                     :ContentType("application/vnd.progress+json")
                                     :UsingBasicAuthentication(oCredentials)
                                     :Request.
        oHttpResp = HttpClient:Instance():Execute(oHttpReq).

        if oHttpResp:StatusCode ne 200 then do:
            oLogger:Error(substitute("Response Code was not HTTP/200: &1", oHttpResp:StatusCode)).
            return ?.
        end. /* Response not HTTP/200 */

        /* Make sure that entity is a true JSON object prior to casting and returning. */
        if valid-object(oHttpResp:Entity) and type-of(oHttpResp:Entity, JsonObject) then
            return cast(oHttpResp:Entity, JsonObject).

        return ?.

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Failed while invoking &1", pcRequestURI)).
            oLogger:Error(substitute("Failed in InvokeAPI: &1", err:GetMessage(1))).
            return ?.
        end catch.
        finally:
            delete object oCredentials no-error.
            delete object oHttpReq no-error.
            delete object oHttpResp no-error.
        end finally.
    end method. /* InvokeAPI */


    method private character InvokeJMX ( input pcQueryPath as character ):
        /**
         * Make a query again the running Java process via JMX to obtain any
         * information or set flags to control monitoring/debugging options.
         *   The -R flag removes the header, leaving only the JSON body.
         *   The -Q flag specifies the name of the query to be executed.
         *   The -O flag sets a specific location for the query output.
         * Example:
         *   oejmx.[bat|sh] -R -Q <catalina_base>/temp/<name>.qry -O <catalina_base>/temp/<output>.json
         */

        define variable cBinaryPath as character no-undo.
        define variable cOutputPath as character no-undo.
        define variable cCommand    as character no-undo.
        define variable iTime       as integer   no-undo.

        if (pcQueryPath gt "") ne true then
            undo, throw new AppError("No query path provided.", 0).

        assign iTime = mtime. /* Each request should be timestamped. */
        assign cBinaryPath = substitute("&1/bin/&2", this-object:CatalinaBase, OEJMXBinary). /* oejmx.[bat|sh] */
        assign cOutputPath = substitute("&1.&2.json", entry(1, pcQueryPath, "."), iTime). /* Temp output file. */

        /* Construct the final command string to be executed. */
        assign cCommand = substitute("&1 -R -Q &2 -O &3", cBinaryPath, pcQueryPath, cOutputPath).

        /* Run command and report information to log file. */
        oLogger:Debug(substitute("Running Command: &1", cCommand)).
        os-command no-console value(cCommand). /* Cannot use silent or no-wait here. */
        oLogger:Debug(substitute("Command Finished: &1 (&2ms)", pcQueryPath, (mtime - iTime))).

        return cOutputPath. /* Return the expected location of the query output. */

        finally:
            os-delete value(pcQueryPath).
        end finally.
    end method. /* InvokeJMX */


    method private character CreateTempQuery ( input pcQueryName as character,
                                               input pcABLApp    as character ):
        /* Pass through without an Agent ID. */
        return this-object:CreateTempQuery(pcQueryName, pcABLApp, 0, 0).
    end method. /* CreateTempQuery */


    method private character CreateTempQuery ( input pcQueryName as character,
                                               input pcABLApp    as character,
                                               input piAgentID   as integer ):
        /* Pass through without an Session ID. */
        return this-object:CreateTempQuery(pcQueryName, pcABLApp, piAgentID, 0).
    end method. /* CreateTempQuery */


    method private character CreateTempQuery ( input pcQueryName as character,
                                               input pcABLApp    as character,
                                               input piAgentID   as integer,
                                               input piSessionID as integer ):
        /**
         * Create a temporary file with the proper OEJMX query to be executed.
         * For some queries there is a replacement necessary, which may need
         * either the application name or an agent ID value.
         */

        define variable cQueryPath   as character         no-undo initial "".
        define variable cQueryString as character         no-undo.
        define variable oParser      as ObjectModelParser no-undo.
        define variable oQuery       as JsonObject        no-undo.

        assign cQueryPath = substitute("&1/&2.qry", this-object:TemporaryDir, pcQueryName).
        assign oParser = new ObjectModelParser().

        case pcQueryName:
            when "agents" then
                assign cQueryString = substitute(this-object:AgentsQuery, pcABLApp).
            when "sessions" then
                assign cQueryString = substitute(this-object:SessionsQuery, piAgentID).
            when "trackon" then
                assign cQueryString = substitute(this-object:TrackOnQuery, piAgentID).
            when "trackoff" then
                assign cQueryString = substitute(this-object:TrackOffQuery, piAgentID).
            when "tracking" then
                assign cQueryString = substitute(this-object:TrackingQuery, piAgentID).
            when "requests" then
                assign cQueryString = substitute(this-object:RequestsQuery, piAgentID).
            when "ablobjects" then
                assign cQueryString = substitute(this-object:ABLObjectsQuery, piAgentID).
            when "ablsessionobjects" then
                assign cQueryString = substitute(this-object:ABLSessionObjectsQuery, piAgentID, piSessionID).
        end case. /* pcQueryName */

        /* Output the modified string to the temporary query file. */
        assign oQuery = cast(oParser:Parse(cQueryString), JsonObject).
        oLogger:Debug(substitute("Writing Query: &1", cQueryPath)).
        oQuery:WriteFile(cQueryPath). /* Send JSON data to disk. */

        return cQueryPath. /* Path to temporary query file. */

        finally:
            delete object oParser no-error.
            delete object oQuery no-error.
        end finally.
    end method. /* CreateTempQuery */


    method private JsonArray FilterABLObjects ( input poObjData as JsonObject,
                                                input pcExclude as character ):
        /**
         * Regardless of how the ABLObjectsReport is obtained, the results from
         * both OEManager and OEJMX should result in the same array of data after
         * filtering the original object. To simplify this process, this method
         * should take the results of either form of query and produce a single
         * array of objects based on the exclusion list provided.
         */

        define variable oReport    as JsonArray  no-undo.
        define variable oObjects   as JsonArray  no-undo.
        define variable oABLObject as JsonObject no-undo.
        define variable cObjName   as character  no-undo.
        define variable cObjSource as character  no-undo.
        define variable lTracking  as logical    no-undo.
        define variable lMatches   as logical    no-undo.
        define variable ix         as integer    no-undo.
        define variable iy         as integer    no-undo.
        define variable iz         as integer    no-undo.

        /* Create the return array. */
        assign oReport = new JsonArray().

        /* Confirm that incoming data is a specific ABLObjects list. */
        if valid-object(poObjData) and poObjData:Has("Objects") and
           poObjData:GetType("Objects") eq JsonDataType:Array then
            assign oObjects = poObjData:GetJsonArray("Objects").

        /* Now parse the objects, filtering out anything that doesn't belong. */
        if valid-object(oObjects) and oObjects:Length gt 0 then
        do iy = 1 to oObjects:Length:
            if pcExclude eq "" then do:
                /* If not excluding specific names, clone the object to the array. */
                oReport:Add(cast(oObjects:GetJsonObject(iy):Clone(), JsonObject)).
            end.
            else if not oObjects:GetJsonObject(iy):Has("Name") then do:
                /* Extract some values for comparison when filtering the results. */
                assign
                    cObjSource = oObjects:GetJsonObject(iy):GetCharacter("Source")
                    lMatches   = false
                    .

                do iz = 1 to num-entries(pcExclude):
                    if cObjSource matches entry(iz, pcExclude) then
                    assign lMatches = true. /* Remember if match found. */
                end. /* do iz */

                /* Retain only objects which DO NOT match the exclusion list. */
                if not lMatches then
                    oReport:Add(cast(oObjects:GetJsonObject(iy):Clone(), JsonObject)).
            end.
            else do:
                /* Extract some values for comparison when filtering the results. */
                assign
                    cObjName   = oObjects:GetJsonObject(iy):GetCharacter("Name")
                    cObjSource = oObjects:GetJsonObject(iy):GetCharacter("Source")
                    lMatches   = false
                    .

                /* Determine if the current object matches the exclusion list. */
                do iz = 1 to num-entries(pcExclude):
                    if cObjName matches entry(iz, pcExclude) or
                       cObjSource matches entry(iz, pcExclude) then
                    assign lMatches = true. /* Remember if match found. */
                end. /* do iz */

                /* Retain only objects which DO NOT match the exclusion list. */
                if not lMatches then
                    oReport:Add(cast(oObjects:GetJsonObject(iy):Clone(), JsonObject)).
            end. /* do (Has Name) */
        end. /* do iy (Objects) */

        return oReport.

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in FilterABLObjects: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            delete object oABLObject no-error.
            delete object oObjects no-error.
        end finally.
    end method. /* FilterABLObjects */


    /***** Public Methods *****/


    method public character GetApplication ( input pcAppList as character extent,
                                             input piAgentID as integer ):
        /**
         * There exists an /applications endpoint for OEManager but no such query for the OEJMX.
         * As such, it is not possible to get a list of appliations reliably from both sources,
         * so instead we will rely on the openedge.properties file which should have all current
         * ABL Application names gathered via the OEMetricsConfig. We will use that with a new
         * request to GetAgents to determine which agents currently belong to which Application.
         * This routine should build a list of available applications with their AgentID's so
         * they can be matched up for subsequent requests.
         */
        define variable cAppNameList  as character  no-undo extent.
        define variable cAppNameMatch as character  no-undo initial "".
        define variable iX            as integer    no-undo.
        define variable iY            as integer    no-undo.

        /* Cycle through the current ABL Applications to find a matching AgentID. */
        assign cAppNameList = Applications:GetNames().
        srchBlk:
        do iX = 1 to extent(cAppNameList):
            /* First check the existing list of unique AgentID's for each ABL Application. */
            if lookup(string(piAgentID), Applications:GetCharacter(cAppNameList[iX])) gt 0 then do:
                /* When the Agent PID exists in the list, return the current ABLApp name.  */
                assign cAppNameMatch = cAppNameList[iX].
                oLogger:Debug(substitute("Matched Agent PID #&1 to ABL Application '&2' [cached].", piAgentID, cAppNameMatch)).
                leave srchBlk. /* Done here. */
            end. /* can-do */
        end. /* do iX */

        /* If nothing found, get the latest list of agents for each ABL Application. */
        if (cAppNameMatch gt "") ne true and extent(pcAppList) ge 1 then
        appBlk:
        do iX = 1 to extent(pcAppList):
            this-object:GetAgents(pcAppList[iX]). /* Get agents of this application name. */

            /* If a PID matches the current ABL Application, set that as the name to return. */
            if lookup(string(piAgentID), Applications:GetCharacter(pcAppList[iX])) gt 0 then do:
                assign cAppNameMatch = pcAppList[iX].
                oLogger:Debug(substitute("Matched Agent PID #&1 to ABL Application '&2' [remote].", piAgentID, cAppNameMatch)).
                leave appBlk. /* Done here. */
            end.
        end. /* do iX */

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in GetApplication: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            return cAppNameMatch.
        end finally.
    end method. /* GetApplication */


    method public void GetAgents ( input pcABLApp as character ):
        define variable oAgentList as JsonArray no-undo.

        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cOutPath as character         no-undo.
            define variable oParser  as ObjectModelParser no-undo.
            define variable oResults as JsonObject        no-undo.

            /* Create the query for obtaining agents, and invoke the JMX command. */
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery("agents", pcABLApp)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return.
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("getAgents") then do:
                    if oResults:GetJsonObject("getAgents"):Has("agents") then
                        assign oAgentList = oResults:GetJsonObject("getAgents"):GetJsonArray("agents").
                end. /* Has Result */
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then
        do on error undo, throw:
            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.

            /* Request a list of agents from the OEManager webapp. */
            assign cRequestURI = substitute("&1&2&3",
                                            this-object:InstanceURI, this-object:ManagerURI,
                                            this-object:GetAllAgentsURI).

            /* Set request with PAS instance name. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp).

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI).
            if valid-object(oRequest) and oRequest:Has("result") then do:
                if oRequest:GetJsonObject("result"):Has("agents") then
                    assign oAgentList = oRequest:GetJsonObject("result"):GetJsonArray("agents").
            end. /* Has Result */

            finally:
                delete object oRequest no-error.
            end finally.
        end. /* oemanager */

        /* Log output results of request. */
        if valid-object(oAgentList) then do:
            define variable iX as integer no-undo.

            oLogger:Trace(substitute("Available Agents: &1", oAgentList:Length)).

            if oAgentList:Length ge 1 then
            do iX = 1 to oAgentList:Length:
                define variable oAgent  as JsonObject no-undo.
                define variable cAgents as character  no-undo initial "".

                /* Add the PID to the list of agents for this ABL Application. */
                assign oAgent = oAgentList:GetJsonObject(iX).
                if valid-object(oAgent) and oAgent:Has("pid") then
                    assign cAgents = trim(substitute("&1,&2", cAgents, oAgent:GetCharacter("pid")), ",").
            end. /* do iY */

            /* Update the requested application with a list of Agent PID's. */
            if Applications:Has(pcABLApp) then
                Applications:Set(pcABLApp, cAgents).
            else
                Applications:Add(pcABLApp, cAgents).
        end. /* valid-object */

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in GetAgents: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            delete object oAgentList no-error.
        end finally.
    end method. /* GetAgents */


    method public void GetSessions ( input  pcABLApp   as character,
                                     input  piAgentID  as integer,
                                     output poSessions as JsonArray ):
        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cOutPath as character         no-undo.
            define variable oParser  as ObjectModelParser no-undo.
            define variable oResults as JsonObject        no-undo.

            /* Create the query for obtaining agents, and invoke the JMX command. */
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery("sessions", pcABLApp, piAgentID)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return. /* No data to return. */
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("getSessionMetrics") then do:
                    if oResults:GetJsonObject("getSessionMetrics"):Has("AgentSession") then
                        poSessions = oResults:GetJsonObject("getSessionMetrics"):GetJsonArray("AgentSession").
                end. /* Has Result */
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then
        do on error undo, throw:
            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.

            /* Request a list of agents from the OEManager webapp. */
            assign cRequestURI = substitute("&1&2&3",
                                            this-object:InstanceURI, this-object:ManagerURI,
                                            this-object:GetAgentSessionURI).

            /* Set request with PAS instance name. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp, piAgentID).

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI).
            if valid-object(oRequest) and oRequest:Has("result") then do:
                if oRequest:GetJsonObject("result"):Has("AgentSession") then
                    poSessions = oRequest:GetJsonObject("result"):GetJsonArray("AgentSession").
            end. /* Has Result */

            finally:
                delete object oRequest no-error.
            end finally.
        end. /* oemanager */

        /* Log output results of request. */
        if valid-object(poSessions) then
            oLogger:Trace(substitute("Available Sessions: &1", poSessions:Length)).

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in GetSessions: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
    end method. /* GetSessions */


    method public logical TrackABLObjects ( input pcABLApp  as character,
                                            input piAgentID as integer,
                                            input plEnable  as logical ):
        define variable lSuccess as logical no-undo initial false.

        if piAgentID le 0 or piAgentID eq ? then return false.

        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cQueryName as character         no-undo.
            define variable cOutPath   as character         no-undo.
            define variable oParser    as ObjectModelParser no-undo.
            define variable oResults   as JsonObject        no-undo.

            /* Create the query for tracking objects, and invoke the JMX command. */
            assign cQueryName = if plEnable then "trackon" else "trackoff".
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery(cQueryName, pcABLApp, piAgentID)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return false.
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("trackABLObjects") then
                    assign lSuccess = (oResults:GetLogical("trackABLObjects") eq true).
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then
        do on error undo, throw:
            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.
            define variable oData       as JsonObject no-undo.

            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            /* Set the base URL to get information for a specific agent. */
            assign cRequestURI = substitute("&1&2&3&4",
                                            this-object:InstanceURI, this-object:ManagerURI,
                                            this-object:GetAgentURI, this-object:TrackObjects).

            /* Build the initial URL, to prepare to set the tracking flag for payload. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp, piAgentID).
            assign oData = new JsonObject().
            if plEnable then
                /* Turn tracking on. */
                oData:Add("enable", "true").
            else
                /* Turn tracking off. */
                oData:Add("enable", "false").

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI, MethodEnum:PUT, oData).
            if valid-object(oRequest) and oRequest:Has("result") then do:
                if not oRequest:IsNull("result") then
                    assign lSuccess = (oRequest:GetLogical("result") eq true).
            end. /* Has Result */

            finally:
                delete object oRequest no-error.
                delete object oData no-error.
            end finally.
        end. /* oemanager */

        /* Report the result of the previous request. */
        oLogger:Debug(substitute("TrackABLObjects (&1): &2 = &3",
                                 piAgentID, trim(string(plEnable, "enabled/disabled")), lSuccess)).

        return lSuccess. /* Return the value from the tracking request. */

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in TrackABLObjects: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
    end method. /* TrackABLObjects */


    method public logical TrackingABLObjects ( input pcABLApp  as character,
                                               input piAgentID as integer ):
        define variable lSuccess as logical no-undo initial false.

        if piAgentID le 0 or piAgentID eq ? then return false.

        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cOutPath as character         no-undo.
            define variable oParser  as ObjectModelParser no-undo.
            define variable oResults as JsonObject        no-undo.

            /* Create the query for tracking objects, and invoke the JMX command. */
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery("tracking", pcABLApp, piAgentID)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return false.
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("trackingABLObjects") then do:
                    /* Return only a true/false value based on value available. */
                    assign lSuccess = (oResults:GetLogical("trackingABLObjects") eq true).
                end. /* Has Result */
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then do:
            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.

            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            /* Build the initial URL, to obtain the tracking flag. */
            assign cRequestURI = substitute("&1&2&3&4",
                                            this-object:InstanceURI, this-object:ManagerURI,
                                            this-object:GetAgentURI, this-object:TrackObjects).

            /* Replace PAS instance name and specific Agent ID. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp, piAgentID).

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI).
            if valid-object(oRequest) and oRequest:Has("result") then do:
                /* Return only a true/false value based on value available. */
                assign lSuccess = (logical(oRequest:GetLogical("result")) eq true).
            end. /* Has Result */
        end. /* oemanager */

        /* Report whether tracking is enabled or disabled for this agent ID. */
        oLogger:Info(substitute("Tracking ABLObjects for Agent '&1': &2", piAgentID, string(lSuccess, "enabled/disabled"))).

        return lSuccess.

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in TrackingABLObjects: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            delete object oRequest no-error.
        end finally.
    end method. /* TrackABLObjects */


    method public logical GetRequestMetrics ( input  pcABLApp   as character,
                                              input  piAgentID  as integer,
                                              output poRequests as JsonArray ):
        define variable oResult as JsonObject no-undo.

        if piAgentID le 0 or piAgentID eq ? then return false.

        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cOutPath as character         no-undo.
            define variable oParser  as ObjectModelParser no-undo.
            define variable oResults as JsonObject        no-undo.

            /* Create the query for tracking objects, and invoke the JMX command. */
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery("requests", pcABLApp, piAgentID)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return false.
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("getRequestMetrics") then do:
                    /* Return only a true/false value based on value available. */
                    assign oResult = oResults:GetJsonObject("getRequestMetrics").
                end. /* Has Result */
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then do:
            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.

            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            /* Build the initial URL, to obtain the tracking flag. */
            assign cRequestURI = substitute("&1&2&3",
                                            this-object:InstanceURI, this-object:ManagerURI, this-object:GetRequestsURI).

            /* Replace PAS instance name and specific Agent ID. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp, piAgentID).

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI).
            if valid-object(oRequest) and oRequest:Has("result") and
               oRequest:GetType("result") eq JsonDataType:Object then do:
                /* Return only a true/false value based on value available. */
                assign oResult = oRequest:GetJsonObject("result").
            end. /* Has Result */
        end. /* oemanager */

        /* Extract requests from the results object. */
        if valid-object(oResult) and oResult:Has("AgentRequest") and
           oResult:GetType("AgentRequest") eq JsonDataType:Array then
            assign poRequests = cast(oResult:GetJsonArray("AgentRequest"):Clone(), JsonArray).

        return valid-object(poRequests).

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in GetRequestMetrics: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            delete object oRequest no-error.
            delete object oResults no-error.
            delete object oResult no-error.
        end finally.
    end method. /* GetRequestMetrics */


    method public logical FilterABLObjectReport ( input  pcABLApp  as character,
                                                  input  piAgentID as integer,
                                                  input  pcExclude as character,
                                                  output poReport  as JsonObject ):
        define variable oABLOutput  as JsonObject no-undo.
        define variable oABLObjects as JsonArray  no-undo.
        define variable oSessionObj as JsonObject no-undo.
        define variable cSessionID  as character  no-undo.
        define variable ix          as integer    no-undo.

        if piAgentID le 0 or piAgentID eq ? then return false.

        /* Leave a quick note about what is being built, and with any exceptions. */
        oLogger:Debug(substitute("Reporting ABLObjects for Agent #&1, excluding: &2", piAgentID, pcExclude)).

        /* Create a new object with our per-session object list. */
        assign poReport = new JsonObject().

        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cOutPath as character         no-undo.
            define variable oParser  as ObjectModelParser no-undo.
            define variable oResults as JsonObject        no-undo.

            /* Create the query for tracking objects, and invoke the JMX command. */
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery("ablobjects", pcABLApp, piAgentID)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return false.
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("getABLObjectsReport") then
                do on error undo, throw:
                    /* Cannot proceed if there is no result. */
                    if oResults:GetType("getABLObjectsReport") ne JsonDataType:Object then return ?.

                    /* Obtain the necessary payload from the result. */
                    if oResults:GetJsonObject("getABLObjectsReport"):Has("ABLOutput") then
                        assign oABLOutput = oResults:GetJsonObject("getABLObjectsReport")
                                                    :GetJsonObject("ABLOutput").
                end. /* has result */
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then
        do on error undo, throw:
            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.

            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            /* Build the initial URL, to obtain ABLObjects report. */
            assign cRequestURI = substitute("&1&2&3&4",
                                            this-object:InstanceURI, this-object:ManagerURI,
                                            this-object:GetAgentURI, this-object:GetObjectsReport).

            /* Replace PAS instance name and specific Agent ID. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp, piAgentID).

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI).
            if valid-object(oRequest) and oRequest:Has("result") then do:
                /* Cannot proceed if there is no result. */
                if oRequest:IsNull("result") then return ?.

                /* Obtain the necessary payload from the result. */
                if oRequest:GetJsonObject("result"):Has("ABLOutput") then
                    assign oABLOutput = oRequest:GetJsonObject("result")
                                                :GetJsonObject("ABLOutput").
            end. /* has result */

            finally:
                delete object oRequest no-error.
            end finally.
        end. /* oemanager */

        /* Limit data to just the ABLObjects data. */
        if valid-object(oABLOutput) and oABLOutput:Has("ABLObjects") and
           oABLOutput:GetType("ABLObjects") eq JsonDataType:Array then
            assign oABLObjects = oABLOutput:GetJsonArray("ABLObjects").

        /* Begin cycling through each session's objects. */
        if valid-object(oABLObjects) then
        do ix = 1 to oABLObjects:Length:
            /* Parse the report payload into a simpler form. */
            assign
                oSessionObj = oABLObjects:GetJsonObject(ix)
                cSessionID  = string(oSessionObj:GetInteger("AgentSessionId"))
                .

            /* Filter the results based on the exclusion list. */
            poReport:Add(cSessionID, this-object:FilterABLObjects(oSessionObj, pcExclude)).

            /* Report how many objects were found within this agent. */
            oLogger:Info(substitute("Total ABLObjects for Agent '&1', Session '&2': &3",
                                    piAgentID, cSessionID,
                                    poReport:GetJsonArray(cSessionID):length)).
        end. /* do ix (ABLObjects) */

        return valid-object(poReport).

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in FilterABLObjectReport: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            delete object oABLOutput no-error.
            delete object oABLObjects no-error.
            delete object oSessionObj no-error.
        end finally.
    end method. /* FilterABLObjectReport */


    method public logical FilterSessionABLObjectReport ( input  pcABLApp    as character,
                                                         input  piAgentID   as integer,
                                                         input  piSessionID as integer,
                                                         input  pcExclude   as character,
                                                         output poReport    as JsonArray ):
        define variable oABLOutput  as JsonObject no-undo.
        define variable oABLObjects as JsonObject no-undo.

        if piAgentID le 0 or piAgentID eq ? then return false.
        if piSessionID le 0 or piSessionID eq ? then return false.

        /* Leave a quick note about what is being built, and with any exceptions. */
        oLogger:Debug(substitute("Reporting ABLObjects for Agent #&1, Session #&2, excluding: &3",
                                 piAgentID, piSessionID, pcExclude)).

        if this-object:MetricSource eq "oejmx" then
        do on error undo, throw:
            define variable cOutPath as character         no-undo.
            define variable oParser  as ObjectModelParser no-undo.
            define variable oResults as JsonObject        no-undo.

            /* Create the query for tracking objects, and invoke the JMX command. */
            assign cOutPath = this-object:InvokeJMX(this-object:CreateTempQuery("ablsessionobjects",
                                                                                pcABLApp, piAgentID, piSessionID)).

            /* Confirm output file exists, and parse the JSON payload. */
            file-info:file-name = cOutPath.
            if file-info:full-pathname ne ? then do:
                if file-info:file-size eq 0 then do:
                    oLogger:Error(substitute("Encountered Empty File: &1", cOutPath)).
                    return false.
                end.

                assign oParser = new ObjectModelParser().
                assign oResults = cast(oParser:ParseFile(cOutPath), JsonObject).

                if valid-object(oResults) and oResults:Has("getABLSessionObjectsReport") then do:
                    /* Cannot proceed if there is no result. */
                    if oResults:GetType("getABLSessionObjectsReport") ne JsonDataType:Object then return ?.

                    /* Obtain the necessary payload from the result. */
                    if oResults:GetJsonObject("getABLSessionObjectsReport"):Has("ABLOutput") then
                        assign oABLOutput = oResults:GetJsonObject("getABLSessionObjectsReport")
                                                    :GetJsonObject("ABLOutput").
                end. /* has result */
            end. /* File Exists */

            finally:
                os-delete value(cOutPath).
                delete object oParser no-error.
                delete object oResults no-error.
            end finally.
        end. /* oejmx */
        else if this-object:MetricSource eq "oemanager" then
        do on error undo, throw:
            define variable cRequestURI as character  no-undo.
            define variable oRequest    as JsonObject no-undo.

            if (this-object:InstanceURI gt "") ne true then
                undo, throw new AppError("No instance URI provided.", 0).

            /* Build the initial URL, to obtain ABLObjects report. */
            assign cRequestURI = substitute("&1&2&3&4",
                                            this-object:InstanceURI, this-object:ManagerURI,
                                            this-object:GetAgentURI, this-object:GetSessionObjectsReport).

            /* Replace PAS instance name and specific Agent ID. */
            assign cRequestURI = substitute(cRequestURI, pcABLApp, piAgentID, piSessionID).

            /* Make the request to the endpoint and parse results. */
            assign oRequest = this-object:InvokeAPI(cRequestURI).
            if valid-object(oRequest) and oRequest:Has("result") then do:
                /* Cannot proceed if there is no result. */
                if oRequest:IsNull("result") then return ?.

                /* Obtain the necessary payload from the result. */
                if oRequest:GetJsonObject("result"):Has("ABLOutput") then
                    assign oABLOutput = oRequest:GetJsonObject("result")
                                                :GetJsonObject("ABLOutput").
            end. /* has result */

            finally:
                delete object oRequest no-error.
            end finally.
        end. /* oemanager */

        /* Limit data to the first ABLObject, which should be the requested session. */
        if valid-object(oABLOutput) and oABLOutput:Has("ABLObjects") and
           oABLOutput:GetType("ABLObjects") eq JsonDataType:Array then
            assign oABLObjects = oABLOutput:GetJsonArray("ABLObjects"):GetJsonObject(1).

        /* Filter the results based on the exclusion list. */
        assign poReport = this-object:FilterABLObjects(oABLObjects, pcExclude).

        /* Report how many objects were found within this agent. */
        oLogger:Info(substitute("Total ABLObjects for Agent '&1', Session '&2': &3",
                                piAgentID, piSessionID, poReport:length)).

        return (poReport:length gt 0).

        catch err as Progress.Lang.Error:
            oLogger:Error(substitute("Error in FilterSessionABLObjectReport: &1", err:GetMessage(1))).
            undo, throw err.
        end catch.
        finally:
            delete object oABLOutput no-error.
            delete object oABLObjects no-error.
        end finally.
    end method. /* FilterSessionABLObjectReport */

end class.
