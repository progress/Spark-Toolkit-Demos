/*------------------------------------------------------------------------
    File        : Sports.Spark.Core.Security.HOTP
    Purpose     : Generate a HOTP code for two-factor authentication
    Description :
    Author(s)   : Dustin Grau (dugrau@progress.com)
    Created     : Fri Oct 13 11:09:53 EST 2017
    Notes       :
    HMAC-based One-Time-Password (HOTP): https://www.ietf.org/rfc/rfc4226.txt
    Shared Secret + Moving Factor (Counter)
    https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm
  ----------------------------------------------------------------------*/

using Progress.Lang.* from propath.

block-level on error undo, throw.

class Spark.Core.Security.HOTP use-widget-pool final:

    define private variable cTokenValue  as character no-undo initial "".
    define private variable iTokenStep   as integer   no-undo initial 30.
    define private variable iTokenLength as integer   no-undo initial 6.

    define public property Token as character no-undo
        get:
            return cTokenValue.
        end get.
        private set.

    define public property EpochCounter as int64 no-undo
        get:
            /* Generate the 64-bit moving portion used in the generation of the OTP. */
            define variable iTemp as int64 no-undo initial 0.
            define variable iTest as int64 no-undo initial 0.

            assign iTemp = int64(mtime(now)).
            assign iTest = iTemp - 0x80000000.
            if (iTest lt 0) then
                return int64(iTemp / iTokenStep).
            else
                return int64(iTest / iTokenStep).
        end get.
        private set.

    constructor public HOTP ( input pcClientSecret as character,
                              input piTokenStep    as integer,
                              input piTokenLength  as integer ):
        super().

        /* Generate a new HOTP token using a specific Step and Length parameters. */
        this-object:newToken(pcClientSecret, piTokenStep, piTokenLength).
    end constructor.

    constructor public HOTP ( input pcToken as character ) :
        super ().

        if (pcToken gt "") ne true then
            undo, throw new AppError("Invalid HOTP token value", 0).

        /* Store a HOTP token value generated by this class */
        assign cTokenValue = pcToken.
        assign iTokenLength = length(pcToken).
    end constructor.

    destructor public HOTP ( ):
        /* Default destructor to overwrite any OTP string value. */
        if (length(cTokenValue) gt 0) then
            assign cTokenValue = fill("x", iTokenLength).
    end destructor.

    method private void newToken ( input pcClientSecret as character,
                                   input piTokenStep    as integer,
                                   input piTokenLength  as integer ):
        define variable cCountHex  as character no-undo.
        define variable cSecretHex as character no-undo.
        define variable cTokenHex  as character no-undo.
        define variable cFormat    as character no-undo.
        define variable iOTPValue  as integer   no-undo.

        if piTokenStep gt 0 and piTokenStep ne iTokenStep then
            assign iTokenStep = piTokenStep. /* Override standard step before requesting counter. */

        /* Obtain secret for hashing via HMAC. */
        assign pcClientSecret = caps(replace(pcClientSecret, " ", "")).
        assign cSecretHex = lc(Spark.Core.Util.Base32:ConvertToHex(pcClientSecret)).

        /* Left-pad with zeroes if less than 16 characters. */
        assign cSecretHex = Spark.Core.Util.Strings:leftPad(cSecretHex, "0", 16).

        /* Obtain counter for hashing via HMAC. */
        assign cCountHex = lc(Spark.Core.Util.Convert:IntToHex(this-object:EpochCounter)).

        /* Left-pad with zeroes if less than 16 characters. */
        assign cCountHex = Spark.Core.Util.Strings:leftPad(cCountHex, "0", 16).

        /* Hash the registered client's secret value and the counter (both as hexadecimal). */
        assign cTokenHex = Spark.Core.Security.HMAC:GenHash("SHA-1", cSecretHex, cCountHex).

        /* Perform truncation to obtain an integer from the hash as our OTP value. */
        assign iOTPValue = Spark.Core.Security.HMAC:TruncateHMAC(cTokenHex).

        /* Turn the integer OTP value into digits for human consumption. */
        if (piTokenLength lt 6) then
            assign piTokenLength = 6.
        if (piTokenLength gt 10) then
            assign piTokenLength = 10.
        assign iTokenLength = piTokenLength.
        assign cTokenValue = string(iOTPValue modulo exp(10, iTokenLength)).
        assign cTokenValue = Spark.Core.Util.Strings:leftPad(cTokenValue, "0", iTokenLength).

        catch err as Progress.Lang.Error:
            if log-manager:logfile-name ne ? then
                log-manager:write-message("newToken: " + err:getMessage(1), "ERROR-OTP").
        end catch.
    end method. /* newToken */

end class.